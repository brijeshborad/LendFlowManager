import { db } from './db';
import { loans, interestEntries, borrowers } from '@shared/schema';
import { eq, and, sql } from 'drizzle-orm';

export interface InterestCalculation {
  loanId: string;
  borrowerId: string;
  userId: string;
  periodStart: Date;
  periodEnd: Date;
  principalAmount: string;
  interestRate: string;
  interestRateType: string;
  interestAmount: string;
}

/**
 * Calculate monthly interest for a single loan
 */
export function calculateMonthlyInterest(
  principalAmount: number,
  annualInterestRate: number,
  interestRateType: 'monthly' | 'annual'
): number {
  if (interestRateType === 'monthly') {
    // Monthly rate is already monthly
    return principalAmount * (annualInterestRate / 100);
  } else {
    // Annual rate needs to be divided by 12
    return principalAmount * (annualInterestRate / 100 / 12);
  }
}

/**
 * Get all active loans that need interest entries for a specific month
 */
export async function getLoansNeedingInterestCalculation(
  targetMonth: Date
): Promise<InterestCalculation[]> {
  try {
    const activeLoans = await db
      .select()
      .from(loans)
      .where(eq(loans.status, 'active'));

    const calculations: InterestCalculation[] = [];

    for (const loan of activeLoans) {
      const startDate = new Date(loan.startDate);
      const currentDate = new Date();
      
      // Calculate which month period we should be calculating
      const periodStart = new Date(startDate);
      const monthsSinceStart = 
        (targetMonth.getFullYear() - startDate.getFullYear()) * 12 +
        (targetMonth.getMonth() - startDate.getMonth());
      
      // Skip if this month is before the loan start date
      if (monthsSinceStart < 0) continue;
      
      // Set period start to the correct month
      periodStart.setMonth(startDate.getMonth() + monthsSinceStart);
      periodStart.setFullYear(startDate.getFullYear() + Math.floor((startDate.getMonth() + monthsSinceStart) / 12));
      
      const periodEnd = new Date(periodStart);
      periodEnd.setMonth(periodEnd.getMonth() + 1);
      
      // Check if we already have an entry for this period
      const existingEntry = await db
        .select()
        .from(interestEntries)
        .where(
          and(
            eq(interestEntries.loanId, loan.id),
            eq(interestEntries.periodStart, periodStart)
          )
        )
        .limit(1);

      // Skip if entry already exists for this period
      if (existingEntry.length > 0) continue;

      const principal = parseFloat(loan.principalAmount);
      const rate = parseFloat(loan.interestRate);
      const interestAmount = calculateMonthlyInterest(
        principal,
        rate,
        loan.interestRateType as 'monthly' | 'annual'
      );

      calculations.push({
        loanId: loan.id,
        borrowerId: loan.borrowerId,
        userId: loan.userId,
        periodStart,
        periodEnd,
        principalAmount: loan.principalAmount,
        interestRate: loan.interestRate,
        interestRateType: loan.interestRateType,
        interestAmount: interestAmount.toFixed(2),
      });
    }

    return calculations;
  } catch (error) {
    console.error('Error getting loans for interest calculation:', error);
    throw error;
  }
}

/**
 * Create interest entries for all loans that need them
 */
export async function generateMonthlyInterestEntries(
  targetMonth?: Date
): Promise<{ created: number; calculations: InterestCalculation[] }> {
  const month = targetMonth || new Date();
  
  try {
    const calculations = await getLoansNeedingInterestCalculation(month);
    
    if (calculations.length === 0) {
      console.log('No interest entries needed for', month.toISOString());
      return { created: 0, calculations: [] };
    }

    // Insert all interest entries
    for (const calc of calculations) {
      await db.insert(interestEntries).values({
        loanId: calc.loanId,
        userId: calc.userId,
        borrowerId: calc.borrowerId,
        periodStart: calc.periodStart,
        periodEnd: calc.periodEnd,
        principalAmount: calc.principalAmount,
        interestRate: calc.interestRate,
        interestAmount: calc.interestAmount,
        isAutoGenerated: true,
        notes: `Auto-generated interest for period ${calc.periodStart.toISOString().split('T')[0]} to ${calc.periodEnd.toISOString().split('T')[0]}`,
      });
    }

    console.log(`âœ… Created ${calculations.length} interest entries for ${month.toISOString().split('T')[0]}`);
    return { created: calculations.length, calculations };
  } catch (error) {
    console.error('Error generating monthly interest entries:', error);
    throw error;
  }
}

/**
 * Get interest history for a specific loan
 */
export async function getInterestHistory(loanId: string) {
  try {
    const entries = await db
      .select()
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching interest history:', error);
    throw error;
  }
}

/**
 * Get all interest entries for a user
 */
export async function getUserInterestEntries(userId: string) {
  try {
    const entries = await db
      .select({
        id: interestEntries.id,
        loanId: interestEntries.loanId,
        borrowerId: interestEntries.borrowerId,
        borrowerName: borrowers.name,
        periodStart: interestEntries.periodStart,
        periodEnd: interestEntries.periodEnd,
        principalAmount: interestEntries.principalAmount,
        interestRate: interestEntries.interestRate,
        interestAmount: interestEntries.interestAmount,
        isAutoGenerated: interestEntries.isAutoGenerated,
        notes: interestEntries.notes,
        createdAt: interestEntries.createdAt,
      })
      .from(interestEntries)
      .leftJoin(borrowers, eq(interestEntries.borrowerId, borrowers.id))
      .where(eq(interestEntries.userId, userId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching user interest entries:', error);
    throw error;
  }
}

/**
 * Calculate total outstanding interest for a loan
 */
export async function calculateOutstandingInterest(loanId: string): Promise<number> {
  try {
    const result = await db
      .select({
        total: sql<number>`COALESCE(SUM(CAST(${interestEntries.interestAmount} AS NUMERIC)), 0)`,
      })
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId));

    return result[0]?.total || 0;
  } catch (error) {
    console.error('Error calculating outstanding interest:', error);
    return 0;
  }
}
