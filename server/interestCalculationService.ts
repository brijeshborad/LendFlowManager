import { db } from './db';
import { loans, interestEntries, borrowers } from '@shared/schema';
import { eq, and, sql } from 'drizzle-orm';

export interface InterestCalculation {
  loanId: string;
  borrowerId: string;
  userId: string;
  periodStart: Date;
  periodEnd: Date;
  principalAmount: string;
  interestRate: string;
  interestRateType: string;
  interestAmount: string;
}

/**
 * Calculate monthly interest for a single loan
 */
export function calculateMonthlyInterest(
  principalAmount: number,
  annualInterestRate: number,
  interestRateType: 'monthly' | 'annual'
): number {
  if (interestRateType === 'monthly') {
    // Monthly rate is already monthly
    return principalAmount * (annualInterestRate / 100);
  } else {
    // Annual rate needs to be divided by 12
    return principalAmount * (annualInterestRate / 100 / 12);
  }
}

/**
 * Get all active loans that need interest entries for a specific month
 */
export async function getLoansNeedingInterestCalculation(
  targetMonth: Date
): Promise<InterestCalculation[]> {
  try {
    const activeLoans = await db
      .select()
      .from(loans)
      .where(eq(loans.status, 'active'));

    const calculations: InterestCalculation[] = [];

    for (const loan of activeLoans) {
      const startDate = new Date(loan.startDate);
      const currentDate = new Date();
      
      // Calculate which month period we should be calculating
      const periodStart = new Date(startDate);
      const monthsSinceStart = 
        (targetMonth.getFullYear() - startDate.getFullYear()) * 12 +
        (targetMonth.getMonth() - startDate.getMonth());
      
      // Skip if this month is before the loan start date
      if (monthsSinceStart < 0) continue;
      
      // Set period start to the correct month
      periodStart.setMonth(startDate.getMonth() + monthsSinceStart);
      periodStart.setFullYear(startDate.getFullYear() + Math.floor((startDate.getMonth() + monthsSinceStart) / 12));
      
      const periodEnd = new Date(periodStart);
      periodEnd.setMonth(periodEnd.getMonth() + 1);
      
      // Check if we already have an entry for this period
      const existingEntry = await db
        .select()
        .from(interestEntries)
        .where(
          and(
            eq(interestEntries.loanId, loan.id),
            eq(interestEntries.periodStart, periodStart)
          )
        )
        .limit(1);

      // Skip if entry already exists for this period
      if (existingEntry.length > 0) continue;

      const principal = parseFloat(loan.principalAmount);
      const rate = parseFloat(loan.interestRate);
      const interestAmount = calculateMonthlyInterest(
        principal,
        rate,
        loan.interestRateType as 'monthly' | 'annual'
      );

      calculations.push({
        loanId: loan.id,
        borrowerId: loan.borrowerId,
        userId: loan.userId,
        periodStart,
        periodEnd,
        principalAmount: loan.principalAmount,
        interestRate: loan.interestRate,
        interestRateType: loan.interestRateType,
        interestAmount: interestAmount.toFixed(2),
      });
    }

    return calculations;
  } catch (error) {
    console.error('Error getting loans for interest calculation:', error);
    throw error;
  }
}

/**
 * Create interest entries for all loans that need them
 */
export async function generateMonthlyInterestEntries(
  targetMonth?: Date
): Promise<{ created: number; calculations: InterestCalculation[] }> {
  const month = targetMonth || new Date();
  
  try {
    const calculations = await getLoansNeedingInterestCalculation(month);
    
    if (calculations.length === 0) {
      console.log('No interest entries needed for', month.toISOString());
      return { created: 0, calculations: [] };
    }

    // Insert all interest entries
    for (const calc of calculations) {
      await db.insert(interestEntries).values({
        loanId: calc.loanId,
        userId: calc.userId,
        borrowerId: calc.borrowerId,
        periodStart: calc.periodStart,
        periodEnd: calc.periodEnd,
        principalAmount: calc.principalAmount,
        interestRate: calc.interestRate,
        interestAmount: calc.interestAmount,
        isAutoGenerated: true,
        notes: `Auto-generated interest for period ${calc.periodStart.toISOString().split('T')[0]} to ${calc.periodEnd.toISOString().split('T')[0]}`,
      });
    }

    console.log(`‚úÖ Created ${calculations.length} interest entries for ${month.toISOString().split('T')[0]}`);
    return { created: calculations.length, calculations };
  } catch (error) {
    console.error('Error generating monthly interest entries:', error);
    throw error;
  }
}

/**
 * Get interest history for a specific loan
 */
export async function getInterestHistory(loanId: string) {
  try {
    const entries = await db
      .select()
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching interest history:', error);
    throw error;
  }
}

/**
 * Get all interest entries for a user
 */
export async function getUserInterestEntries(userId: string) {
  try {
    const entries = await db
      .select({
        id: interestEntries.id,
        loanId: interestEntries.loanId,
        borrowerId: interestEntries.borrowerId,
        borrowerName: borrowers.name,
        periodStart: interestEntries.periodStart,
        periodEnd: interestEntries.periodEnd,
        principalAmount: interestEntries.principalAmount,
        interestRate: interestEntries.interestRate,
        interestAmount: interestEntries.interestAmount,
        isAutoGenerated: interestEntries.isAutoGenerated,
        notes: interestEntries.notes,
        createdAt: interestEntries.createdAt,
      })
      .from(interestEntries)
      .leftJoin(borrowers, eq(interestEntries.borrowerId, borrowers.id))
      .where(eq(interestEntries.userId, userId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching user interest entries:', error);
    throw error;
  }
}

/**
 * Calculate total outstanding interest for a loan
 */
export async function calculateOutstandingInterest(loanId: string): Promise<number> {
  try {
    const result = await db
      .select({
        total: sql<number>`COALESCE(SUM(CAST(${interestEntries.interestAmount} AS NUMERIC)), 0)`,
      })
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId));

    return result[0]?.total || 0;
  } catch (error) {
    console.error('Error calculating outstanding interest:', error);
    return 0;
  }
}

/**
 * Generate all historical interest entries for a loan from its start date to now
 * This is called when a loan is created with a historical start date
 */
export async function generateHistoricalInterestEntries(
  loanId: string,
  userId: string,
  borrowerId: string,
  startDate: Date,
  principalAmount: string,
  interestRate: string,
  interestRateType: 'monthly' | 'annual'
): Promise<{ created: number; entries: any[] }> {
  try {
    const now = new Date();
    const loanStartDate = new Date(startDate);
    const entries = [];
    
    // Calculate number of months between start date and now
    const monthsDiff = 
      (now.getFullYear() - loanStartDate.getFullYear()) * 12 +
      (now.getMonth() - loanStartDate.getMonth());

    console.log(`üìä Generating historical interest entries for loan ${loanId}: ${monthsDiff + 1} months`);

    // Generate an interest entry for each month from start to now
    for (let i = 0; i <= monthsDiff; i++) {
      const periodStart = new Date(loanStartDate);
      periodStart.setMonth(loanStartDate.getMonth() + i);
      
      const periodEnd = new Date(periodStart);
      periodEnd.setMonth(periodEnd.getMonth() + 1);
      
      // Check if entry already exists for this period
      const existingEntry = await db
        .select()
        .from(interestEntries)
        .where(
          and(
            eq(interestEntries.loanId, loanId),
            eq(interestEntries.periodStart, periodStart)
          )
        )
        .limit(1);

      // Skip if entry already exists
      if (existingEntry.length > 0) {
        console.log(`‚è≠Ô∏è  Entry already exists for period ${periodStart.toISOString().split('T')[0]}`);
        continue;
      }

      const principal = parseFloat(principalAmount);
      const rate = parseFloat(interestRate);
      const interestAmount = calculateMonthlyInterest(principal, rate, interestRateType);

      // Create the interest entry
      const entry = await db.insert(interestEntries).values({
        loanId,
        userId,
        borrowerId,
        periodStart,
        periodEnd,
        principalAmount,
        interestRate,
        interestAmount: interestAmount.toFixed(2),
        isAutoGenerated: true,
        notes: `Auto-generated ${interestRateType} interest for period ${periodStart.toISOString().split('T')[0]} to ${periodEnd.toISOString().split('T')[0]}`,
      }).returning();

      entries.push(entry[0]);
      console.log(`‚úÖ Created interest entry: ${periodStart.toISOString().split('T')[0]} - ‚Çπ${interestAmount.toFixed(2)}`);
    }

    console.log(`üéâ Successfully created ${entries.length} historical interest entries`);
    return { created: entries.length, entries };
  } catch (error) {
    console.error('Error generating historical interest entries:', error);
    throw error;
  }
}
