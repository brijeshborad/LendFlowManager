import { db } from './db';
import { loans, interestEntries, borrowers } from '@shared/schema';
import { eq, and, sql } from 'drizzle-orm';

export interface InterestCalculation {
  loanId: string;
  borrowerId: string;
  userId: string;
  periodStart: Date;
  periodEnd: Date;
  principalAmount: string;
  interestRate: string;
  interestRateType: string;
  interestAmount: string;
}

/**
 * Safely add months to a date, handling end-of-month edge cases
 * For example: Jan 31 + 1 month = Feb 28/29 (not Mar 3)
 */
function addMonthsSafe(date: Date, monthsToAdd: number): Date {
  const result = new Date(date);
  const originalDay = result.getDate();
  
  // Add the months
  result.setMonth(result.getMonth() + monthsToAdd);
  
  // If the day changed (overflow), set to last day of target month
  if (result.getDate() !== originalDay) {
    // Go to the 0th day of next month (which is last day of current month)
    result.setDate(0);
  }
  
  return result;
}

/**
 * Calculate real-time interest for a loan based on 30-day months
 */
function calculateRealTimeInterest(
  principalAmount: number,
  interestRate: number,
  interestRateType: 'monthly' | 'annual',
  startDate: Date,
  endDate: Date = new Date()
): number {
  // Calculate days treating all months as exactly 30 days
  let adjustedDays = 0;
  let currentDate = new Date(startDate);
  
  while (currentDate < endDate) {
    const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
    const monthEnd = endOfMonth < endDate ? endOfMonth : endDate;
    const daysToCount = Math.ceil((monthEnd.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24));
    
    // Always count exactly 30 days per month (treat all months as 30 days)
    adjustedDays += Math.min(daysToCount, 30);
    
    // If we've completed a full month, always add 30 days regardless of actual month length
    if (monthEnd === endOfMonth && currentDate.getDate() === 1) {
      adjustedDays = adjustedDays - daysToCount + 30;
    }
    
    currentDate.setMonth(currentDate.getMonth() + 1);
    currentDate.setDate(1);
  }
  
  const exactMonths = adjustedDays / 30;
  
  if (interestRateType === 'monthly') {
    return principalAmount * (interestRate / 100) * exactMonths;
  } else {
    return principalAmount * (interestRate / 100 / 12) * exactMonths;
  }
}

/**
 * Calculate total interest for all active loans in real-time
 */
export async function calculateRealTimeInterestForUser(userId: string) {
  try {
    const activeLoans = await db
      .select()
      .from(loans)
      .where(and(eq(loans.userId, userId), eq(loans.status, 'active')));

    const today = new Date();
    today.setHours(0, 0, 0, 0); // Set to start of today

    const loanInterests = activeLoans.map(loan => {
      const principal = parseFloat(loan.principalAmount);
      const rate = parseFloat(loan.interestRate);
      const totalInterest = calculateRealTimeInterest(
        principal,
        rate,
        loan.interestRateType as 'monthly' | 'annual',
        new Date(loan.startDate),
        today // Use today instead of default
      );
      
      return {
        loanId: loan.id,
        borrowerId: loan.borrowerId,
        totalInterest,
        startDate: loan.startDate
      };
    });

    return loanInterests;
  } catch (error) {
    console.error('Error calculating real-time interest:', error);
    throw error;
  }
}

/**
 * Create interest entries for all loans that need them
 */
export async function generateMonthlyInterestEntries(
  targetMonth?: Date
): Promise<{ created: number; calculations: InterestCalculation[] }> {
  const month = targetMonth || new Date();
  
  try {
    const calculations = await getLoansNeedingInterestCalculation(month);
    
    if (calculations.length === 0) {
      console.log('No interest entries needed for', month.toISOString());
      return { created: 0, calculations: [] };
    }

    // Insert all interest entries
    for (const calc of calculations) {
      await db.insert(interestEntries).values({
        loanId: calc.loanId,
        userId: calc.userId,
        borrowerId: calc.borrowerId,
        periodStart: calc.periodStart,
        periodEnd: calc.periodEnd,
        principalAmount: calc.principalAmount,
        interestRate: calc.interestRate,
        interestAmount: calc.interestAmount,
        isAutoGenerated: true,
        notes: `Auto-generated interest for period ${calc.periodStart.toISOString().split('T')[0]} to ${calc.periodEnd.toISOString().split('T')[0]}`,
      });
    }

    console.log(`‚úÖ Created ${calculations.length} interest entries for ${month.toISOString().split('T')[0]}`);
    return { created: calculations.length, calculations };
  } catch (error) {
    console.error('Error generating monthly interest entries:', error);
    throw error;
  }
}

/**
 * Get interest history for a specific loan
 */
export async function getInterestHistory(loanId: string) {
  try {
    const entries = await db
      .select()
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching interest history:', error);
    throw error;
  }
}

/**
 * Get all interest entries for a user
 */
export async function getUserInterestEntries(userId: string) {
  try {
    const entries = await db
      .select({
        id: interestEntries.id,
        loanId: interestEntries.loanId,
        borrowerId: interestEntries.borrowerId,
        borrowerName: borrowers.name,
        periodStart: interestEntries.periodStart,
        periodEnd: interestEntries.periodEnd,
        principalAmount: interestEntries.principalAmount,
        interestRate: interestEntries.interestRate,
        interestAmount: interestEntries.interestAmount,
        isAutoGenerated: interestEntries.isAutoGenerated,
        notes: interestEntries.notes,
        createdAt: interestEntries.createdAt,
      })
      .from(interestEntries)
      .leftJoin(borrowers, eq(interestEntries.borrowerId, borrowers.id))
      .where(eq(interestEntries.userId, userId))
      .orderBy(sql`${interestEntries.periodStart} DESC`);

    return entries;
  } catch (error) {
    console.error('Error fetching user interest entries:', error);
    throw error;
  }
}

/**
 * Calculate total outstanding interest for a loan
 */
export async function calculateOutstandingInterest(loanId: string): Promise<number> {
  try {
    const result = await db
      .select({
        total: sql<number>`COALESCE(SUM(CAST(${interestEntries.interestAmount} AS NUMERIC)), 0)`,
      })
      .from(interestEntries)
      .where(eq(interestEntries.loanId, loanId));

    return result[0]?.total || 0;
  } catch (error) {
    console.error('Error calculating outstanding interest:', error);
    return 0;
  }
}

/**
 * Generate all historical interest entries for a loan from its start date to now
 * This is called when a loan is created with a historical start date
 */
export async function generateHistoricalInterestEntries(
  loanId: string,
  userId: string,
  borrowerId: string,
  startDate: Date,
  principalAmount: string,
  interestRate: string,
  interestRateType: 'monthly' | 'annual'
): Promise<{ created: number; entries: any[] }> {
  try {
    const now = new Date();
    const loanStartDate = new Date(startDate);
    const entries = [];
    
    // Calculate number of months between start date and now
    const monthsDiff = 
      (now.getFullYear() - loanStartDate.getFullYear()) * 12 +
      (now.getMonth() - loanStartDate.getMonth());

    console.log(`üìä Generating historical interest entries for loan ${loanId}: ${monthsDiff + 1} months`);

    // Generate an interest entry for each month from start to now
    for (let i = 0; i <= monthsDiff; i++) {
      // Use safe month addition to avoid skipping months for 29th-31st dates
      const periodStart = addMonthsSafe(loanStartDate, i);
      const periodEnd = addMonthsSafe(loanStartDate, i + 1);
      
      // Check if entry already exists for this period
      const existingEntry = await db
        .select()
        .from(interestEntries)
        .where(
          and(
            eq(interestEntries.loanId, loanId),
            eq(interestEntries.periodStart, periodStart)
          )
        )
        .limit(1);

      // Skip if entry already exists
      if (existingEntry.length > 0) {
        console.log(`‚è≠Ô∏è  Entry already exists for period ${periodStart.toISOString().split('T')[0]}`);
        continue;
      }

      const principal = parseFloat(principalAmount);
      const rate = parseFloat(interestRate);
      const interestAmount = calculateMonthlyInterest(principal, rate, interestRateType);

      // Create the interest entry
      const entry = await db.insert(interestEntries).values({
        loanId,
        userId,
        borrowerId,
        periodStart,
        periodEnd,
        principalAmount,
        interestRate,
        interestAmount: interestAmount.toFixed(2),
        isAutoGenerated: true,
        notes: `Auto-generated ${interestRateType} interest for period ${periodStart.toISOString().split('T')[0]} to ${periodEnd.toISOString().split('T')[0]}`,
      }).returning();

      entries.push(entry[0]);
      console.log(`‚úÖ Created interest entry: ${periodStart.toISOString().split('T')[0]} - ‚Çπ${interestAmount.toFixed(2)}`);
    }

    console.log(`üéâ Successfully created ${entries.length} historical interest entries`);
    return { created: entries.length, entries };
  } catch (error) {
    console.error('Error generating historical interest entries:', error);
    throw error;
  }
}
